<!DOCTYPE html>
<html lang="en-US">
  <head>
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <link href="../../assets/styles/article.css" rel="stylesheet" type="text/css" /> 
    <title>CS 220: Homework 2</title>
    <link href="https://unpkg.com/purecss@1.0.0/build/pure-min.css" 
       rel="stylesheet"/>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML" async=""></script>    
<link href="hw2/hl-fine_blue.css" rel="stylesheet"/>
  </head>
  <body>
    <nav>
      <ul>
	<li><a href="../../index.html" class="material-icons">house</a></li>
	<li><a href="../../docs/index.html">Docs</a></li>
	<li><a href="../../exams-quizzes/index.html">Exams &amp; Quizzes</a></li>
	<li><a href="../../exercises/index.html">Exercises</a></li>
	<li><a href="../../hws/index.html">Homeworks</a></li>
	<li><a href="../../labs/index.html">Labs</a></li>
	<li><a href="../../misc/index.html">Misc</a></li>
	<li><a href="../../projects/index.html">Projects</a></li>
	<li><a href="../../slides/index.html">Slides</a></li>
      </ul>
    </nav>
    <div class="content">
      <section data-coord="hw2.umt:1:0"><h1 data-coord="hw2.umt:1:0">Homework 2</h1><p data-coord="hw2.umt:3:0"><strong data-coord="hw2.umt:3:0">Due</strong>: Oct 4						<strong data-coord="hw2.umt:3:18">Max. Points</strong>: 100
</p><p data-coord="hw2.umt:5:0"><strong data-coord="hw2.umt:5:0">Please justify all answers</strong>.
</p><p data-coord="hw2.umt:7:0">To be submitted <strong data-coord="hw2.umt:7:16">on paper, during class</strong>.  <strong data-coord="hw2.umt:7:43">No late submissions</strong>
</p><p data-coord="hw2.umt:9:0"><strong data-coord="hw2.umt:9:0">Important Reminder</strong>: As per the course <em data-coord="hw2.umt:9:110"><a href="../../misc/academic-honesty-statement/academic-honesty-policy.html" data-coord="hw2.umt:9:110">Academic Honesty Statement</a></em>,
cheating of any kind will minimally result in receiving an F letter
grade for the entire course.
</p><p data-coord="hw2.umt:13:0">Note that using a computer can help solve some of these problems.
However, to ensure that you understand the concepts fully, you should
not make use of one. Recollect that you will not be allowed to use a
computer during the exams.
</p><p data-coord="hw2.umt:18:0">In the answers which follow, underscores are used within number literals
to aid readability.
</p><ol data-coord="hw2.umt:21:0"><li data-coord="hw2.umt:21:0"><p data-coord="hw2.umt:21:4">One way of negating a 2's-complement integer \(N\) is to compute \(
    1 + (\sim\!N)\).  Prove that this procedure works.  <em data-coord="hw2.umt:21:126">10-points</em>
</p><p data-coord="hw2.umt:25:4"><strong data-coord="hw2.umt:25:4">Hint</strong>: Recall that the value of an \(n\)-bit number
 \(b_{n-1}b_{n-2}\ldots b_1 b_0\) is:
</p>\[     -b_{n-1}\times 2^{n-1} + b_{n-2}\times 2^{n-2} + \ldots
     + b_1\times 2^1 + b_0\times 2^0
\]</li><li data-coord="hw2.umt:33:0"><p data-coord="hw2.umt:33:4">Given a 10-bit floating-point number with a 4-bit exponent field
which follows IEEE floating point rules except for the above
sizes:
</p><ol data-coord="hw2.umt:37:0"><li data-coord="hw2.umt:37:0"><p data-coord="hw2.umt:37:8">What is the hexadecimal representation of the bit-pattern
representing minus infinity?
</p></li><li data-coord="hw2.umt:40:0"><p data-coord="hw2.umt:40:8">Give the hexadecimal representation of the bit-pattern
and the decimal value of the smallest positive number.
</p></li><li data-coord="hw2.umt:43:0"><p data-coord="hw2.umt:43:8">Give the hexadecimal representation of the bit-pattern and the
decimal value of the smallest positive normalized number.
</p></li><li data-coord="hw2.umt:46:0"><p data-coord="hw2.umt:46:8">Give the hexadecimal representation of the bit-pattern and the
decimal value for the most negative number which is not minus
infinity.
</p></li><li data-coord="hw2.umt:50:0"><p data-coord="hw2.umt:50:8">Give the smallest and largest ULP values possible in
this representation.
</p></li></ol><p data-coord="hw2.umt:53:4">You should use a calculator to provide exact answers for the
decimal values. <em data-coord="hw2.umt:53:85">15-points</em>
</p></li><li data-coord="hw2.umt:55:0"><p data-coord="hw2.umt:55:4">The floating point formats popular on most present-day computers
use binary and hence cannot represent decimal numbers exactly.
For example, the number <samp data-coord="hw2.umt:55:164">0.1</samp> cannot be represented exactly in
these formats.  This can be a problem in situations like financial
applications where exact decimal calculations are required.
</p><p data-coord="hw2.umt:61:4">There are various alternatives to binary floating point formats.
This problem explores one alternative: the use of a Binary-Coded
Decimal <a href="http://en.wikipedia.org/wiki/Binary-coded_decimal" data-coord="hw2.umt:61:203">BCD</a>
floating point format.
</p><p data-coord="hw2.umt:66:4">The BCD representation of integers is straight-forward: each
decimal digit is represented using its normal 4-bit binary
encoding.  For example, the decimal number <samp data-coord="hw2.umt:66:175">1234</samp> is represented
using 4 nybbles: <samp data-coord="hw2.umt:66:218">0001 0010 0011 0100</samp>.  Since there are two
nybbles to a byte, the hex representation of the BCD
representation of decimal <samp data-coord="hw2.umt:66:349">1234</samp> is simply <samp data-coord="hw2.umt:66:366">0x1234</samp>.
</p><p data-coord="hw2.umt:73:4">This problem deals with a 64-bit floating point BCD format
<samp data-coord="hw2.umt:73:67">BcdFloat</samp> where the decimal point can float within the least
significant digits.  Specifically, the 15 least significant
nybbles of the 16 nybbles available within a 64-bit word are used
to hold the 15 BCD-encoded digits of the number (with
least-significant digit in the least-significant nybble).  The MSB
of the most significant nybble is used as a sign bit, with <samp data-coord="hw2.umt:73:455">1</samp>
representing a negative number.  The remaining 3 bits of the most
significant nybble give the position of the decimal point;
specifically they are interpreted as an unsigned binary number
giving the number of digits to the right of the decimal point.
</p><p data-coord="hw2.umt:85:4">Here are some examples of numbers in this representation (underscores
are used for readability):     
</p><pre data-coord="hw2.umt:89:0">                     1:  0x00_00_00_00_00_00_00_01
                  1234:  0x00_00_00_00_00_00_12_34
                 -1234:  0x80_00_00_00_00_00_12_34
                 12.34:  0x20_00_00_00_00_00_12_34
                -12.34:  0xA0_00_00_00_00_00_12_34
	         1.234:  0x30_00_00_00_00_00_12_34
	        -1.234:  0xB0_00_00_00_00_00_12_34
       123456789012345:  0x01_23_45_67_89_01_23_45
      -123456789012345:  0x81_23_45_67_89_01_23_45
     -12345678.9012345:  0xF1_23_45_67_89_01_23_45
</pre><ol data-coord="hw2.umt:102:0"><li data-coord="hw2.umt:102:0"><p data-coord="hw2.umt:102:10">What is the ratio of the magnitude of the largest
non-infinite IEEE double-precision float to the magnitude of
the largest <samp data-coord="hw2.umt:102:153">BcdFloat</samp>?
</p></li><li data-coord="hw2.umt:106:0"><p data-coord="hw2.umt:106:10">What is the ratio of the magnitude of the smallest non-zero
IEEE double-precision float to the magnitude of the smallest
non-zero <samp data-coord="hw2.umt:106:160">BcdFloat</samp>?
</p></li><li data-coord="hw2.umt:110:0"><p data-coord="hw2.umt:110:10">The ratio of the magnitude of the smallest ULP magnitude for
the IEEE double-precision float to the smallest ULP
magnitude for the <samp data-coord="hw2.umt:110:147">BcdFloat</samp>.
</p></li></ol><p data-coord="hw2.umt:114:6">You should use a calculator to give a specific value for these
ratios. <em data-coord="hw2.umt:114:83">15-points</em>
</p></li><li data-coord="hw2.umt:117:0"><p data-coord="hw2.umt:117:4">Given the following declaration of a variable <samp data-coord="hw2.umt:117:50">s</samp>, show the memory
address and contents of each individual byte of memory occupied by
<samp data-coord="hw2.umt:117:146">s</samp> in hexadecimal.
</p><pre>    <span class="hl kwb">struct</span> S <span class="hl opt">{</span>
      <span class="hl kwb">int</span> val<span class="hl opt">;</span>
      <span class="hl kwb">int</span> name<span class="hl opt">[</span><span class="hl num">4</span><span class="hl opt">];</span>
      <span class="hl kwb">struct</span> S <span class="hl opt">*</span>next<span class="hl opt">;</span>
    <span class="hl opt">}</span> s <span class="hl opt">= {</span>
      <span class="hl num">0xdeadbeef</span><span class="hl opt">,</span>
      <span class="hl str">&quot;42&quot;</span><span class="hl opt">,</span>
      <span class="hl opt">&amp;</span>s
    <span class="hl opt">};</span></pre><p data-coord="hw2.umt:133:4">You should assume the following:
</p><ul data-coord="hw2.umt:135:0"><li data-coord="hw2.umt:135:0"><p data-coord="hw2.umt:135:8"><samp data-coord="hw2.umt:135:8">s</samp> is allocated at <samp data-coord="hw2.umt:135:28">0x8000</samp>.
</p></li><li data-coord="hw2.umt:137:0"><p data-coord="hw2.umt:137:8">Fields in a <samp data-coord="hw2.umt:137:20">struct</samp> are packed together without any
wasted space.
</p></li><li data-coord="hw2.umt:140:0"><p data-coord="hw2.umt:140:8">Characters are encoded in UTF-8.
</p></li><li data-coord="hw2.umt:142:0"><p data-coord="hw2.umt:142:8">Pointers and <samp data-coord="hw2.umt:142:21">int</samp>'s occupy 4 bytes.
</p></li><li data-coord="hw2.umt:144:0"><p data-coord="hw2.umt:144:8">Multi-byte quantities use a little-endian byte
ordering.
</p></li></ul><p data-coord="hw2.umt:147:4">If the contents of a byte are undefined, indicate it by <samp data-coord="hw2.umt:147:60">uu</samp>. <em data-coord="hw2.umt:147:66">10-points</em>
</p></li><li data-coord="hw2.umt:150:0"><p data-coord="hw2.umt:150:4">Given the following C function:
</p><pre>    <span class="hl kwb">void</span> <span class="hl kwd">f</span><span class="hl opt">(</span><span class="hl kwb">int</span> <span class="hl opt">*</span>p1<span class="hl opt">,</span> <span class="hl kwb">int</span> <span class="hl opt">*</span>p2<span class="hl opt">) {</span>
      <span class="hl opt">*</span>p1 <span class="hl opt">=</span> <span class="hl num">5</span><span class="hl opt">;</span>
      <span class="hl opt">*</span>p2 <span class="hl opt">=</span> <span class="hl num">6</span><span class="hl opt">;</span>
      <span class="hl kwd">printf</span><span class="hl opt">(</span><span class="hl str">&quot;%d %d</span><span class="hl esc">\n</span><span class="hl str">&quot;</span><span class="hl opt">, *</span>p1<span class="hl opt">, *</span>p2<span class="hl opt">);</span>
    <span class="hl opt">}</span></pre><p data-coord="hw2.umt:160:4">show a call to <samp data-coord="hw2.umt:160:19">f()</samp> such that something <strong data-coord="hw2.umt:160:45">other</strong> than a line
containing <samp data-coord="hw2.umt:160:80">5 6</samp> is printed. <em data-coord="hw2.umt:160:98">10-points</em>
</p></li><li data-coord="hw2.umt:163:0"><p data-coord="hw2.umt:163:4">The solution to problem 7 for <em data-coord="hw2.umt:163:61"><a href="../hw1-sol/hw1-sol.html" data-coord="hw2.umt:163:61">Homework
    1</a></em>, packed multiple integer values with limited range into a
single <samp data-coord="hw2.umt:163:147">int</samp> using explicit bit-twiddling.  C provides an
alternate way of achieving something similar using <samp data-coord="hw2.umt:163:253">struct</samp>
<a href="http://www.tutorialspoint.com/cprogramming/c_bit_fields.htm" data-coord="hw2.umt:163:333">bit-fields.</a>
</p><p data-coord="hw2.umt:170:4">Use the web or any C books to research C <samp data-coord="hw2.umt:170:45">struct</samp> bit-fields and
then contrast the packing of multiple integral values into a
single integer using explicit bit-twiddling with that done using C
<samp data-coord="hw2.umt:170:209">struct</samp> bit-fields.  <em data-coord="hw2.umt:170:231">10-points</em>
</p></li><li data-coord="hw2.umt:174:0"><p data-coord="hw2.umt:174:4">Find any bugs or inadequacies in the following program which
purports to be a filter which copies its standard input to
standard output while transforming any linefeed character <samp data-coord="hw2.umt:174:190">'\n'</samp>
in the input to a carriage-return <samp data-coord="hw2.umt:174:235">'\r'</samp>, line-feed <samp data-coord="hw2.umt:174:253">'\n'</samp> pair.
</p><pre>    <span class="hl kwb">int</span> <span class="hl kwd">main</span><span class="hl opt">() {</span>
      <span class="hl kwb">char</span> c<span class="hl opt">;</span>
      <span class="hl kwa">do</span> <span class="hl opt">{</span>
        c <span class="hl opt">=</span> <span class="hl kwd">fgetc</span><span class="hl opt">(</span>stdin<span class="hl opt">);</span>
        <span class="hl kwd">fputc</span><span class="hl opt">(</span>stdout<span class="hl opt">,</span> c<span class="hl opt">);</span>
        <span class="hl kwa">if</span> <span class="hl opt">(</span>c <span class="hl opt">==</span> <span class="hl str">&apos;</span><span class="hl esc">\n</span><span class="hl str">&apos;</span><span class="hl opt">)</span> <span class="hl kwd">fputc</span><span class="hl opt">(</span>stdout<span class="hl opt">,</span> <span class="hl str">&apos;</span><span class="hl esc">\r</span><span class="hl str">&apos;</span><span class="hl opt">);</span>
      <span class="hl opt">}</span> <span class="hl kwa">while</span> <span class="hl opt">(</span>c <span class="hl opt">!=</span> EOF<span class="hl opt">);</span>
    <span class="hl opt">}</span></pre><p data-coord="hw2.umt:190:4">You should assume that all required header files have been
included.  You should consult the manual pages for the library
functions used above.  <em data-coord="hw2.umt:190:157">15-points</em>
</p></li><li data-coord="hw2.umt:195:0"><p data-coord="hw2.umt:195:4">Discuss the validity of the following statements. What is more
important than whether you ultimately classify the statement as
<strong data-coord="hw2.umt:195:139">true</strong> or <strong data-coord="hw2.umt:195:149">false</strong> is your justification for arriving at your
conclusion. <em data-coord="hw2.umt:195:216">15-points</em>
</p><ol data-coord="hw2.umt:200:0"><li data-coord="hw2.umt:200:0"><p data-coord="hw2.umt:200:8">An IEEE single-precision floating point number has multiple
representations for zero.
</p></li><li data-coord="hw2.umt:203:0"><p data-coord="hw2.umt:203:8">C does not allow taking the address of a variable which points
to an <samp data-coord="hw2.umt:203:85">int</samp> as such an expression does not make any sense.
</p></li><li data-coord="hw2.umt:206:0"><p data-coord="hw2.umt:206:8">C does not allow adding 2 pointers as such an expression
does not make any sense.
</p></li><li data-coord="hw2.umt:209:0"><p data-coord="hw2.umt:209:8">C does not allow adding a <samp data-coord="hw2.umt:209:34">int</samp> to a pointer as such an expression
does not make any sense.
</p></li><li data-coord="hw2.umt:212:0"><p data-coord="hw2.umt:212:8">The use of an array name in any expression (not a declaration)
is transformed into a pointer to its first element.
</p></li></ol></li></ol></section>
    </div> <!-- #content -->
  </body>
</html>
